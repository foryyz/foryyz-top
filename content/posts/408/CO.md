---
title: '计算机组成原理'
date: 2025-09-23T11:13:20+08:00
draft: false
---

# 计算机组成原理

## 1 计算机系统概述

### 1.1 计算机发展历程

计算机系统 = 硬件 + 软件
	软件 = 系统软件 + 应用软件



### 1.2.1 计算机硬件的基本组成

#### 早期 冯诺依曼结构

- 计算机由五大部件组成 (I/O、存储器、运算器、控制器)
- 指令和数据以同等地位存于存储器，可按地址寻访
- 指令和数据用二进制表示
- 指令由操作码和地址码组成
- 存储程序
- 以运算器为中心 (输入/输出设备与存储器之间的数据传送通过运算器完成)

#### 现代计算机

- 以存储器为中心

CPU = 运算器+控制器



### 1.2.2 硬件工作原理

#### 1.2.2.1 主存储器的基本组成 

**主存储器 = 存储体+MAR+MDR**

**存储体**内 一个地址对应一个**存储单元**，每个**存储单元**存放一串二进制代码，这串二进制代码叫做**存储字(word)**

**存储元**：即存储二进制的电子元件，每个存储元可存1bit

**MAR**位数反映存储单元的个数，MAR=4位 即 共有$2^4$个存储单元

**MDR**位数 = 存储字长，MDR=16位 即 每个存储单元可存放16bit，一个字(word)=16bit

注：1个字节(Byte)=8bit，1B=1个字节, 1b=1bit

#### 1.2.2.2 运算器的基本组成

**ACC**: 累加器，用于存放操作数，或运算结果

**MQ**: 乘商寄存器，在乘、除运算时，用于存放操作数或运算结果

**X**: 通用的操作数寄存器，用于存放操作数

**ALU**: 算数逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算

#### 1.2.2.3 控制器的基本组成

**CU**: 控制单元，分析指令，给出控制信号

**IR**: 指令寄存器，存放当前执行的指令

**PC**: 程序计数器，存放下一条指令地址，有自动加1功能

完成一条指令的步骤：1️⃣取指令(PC) 2️⃣分析指令(IR) 3️⃣执行指令(CU)

#### 1.2.2.4 计算机的工作过程

初始 指令、数据存入主存，PC指向第一条指令
从主存中取指令放入IR、PC自动加1、CU分析指令、CU指挥其他部件执行指令

(可以以此 深刻理解 冯诺伊曼的计算机结构特点)



### 1.2.3 计算机软件

软件 = 系统软件+应用软件 

编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序 (只需翻译一次)
解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句 (每次执行都要翻译)



### 1.2.4 计算机系统的多级层次结构

计算机组成原理 -- 如何用硬件实现所定义的接口

- M4 - 高级语言机器 (执行高级语言)
- M3 - 汇编语言机器 (执行汇编语言, 将汇编程序翻译成机器语言程序)
- M2 - 操作系统机器 (向上提供广义指令)
- M1 - 传统机器 (执行机器语言指令)
- M0 - 微程序机器 (执行微指令)



### 1.2.5 计算机系统的工作原理

编程 -> **hello.c** --(预处理器)>> **hello.i** --(编译器)>> **hello.s** --(汇编器)>> **hello.o** --(与其他模块-> 链接器)>> **可执行文件hello.exe**

编译器：将预处理后的源程序 翻译为 汇编语言

汇编器：将汇编语言程序翻译为二进制机器语言

链接器：将多个相关的目标模块链接成完整的可执行文件



### 1.3 计算机的性能指标

#### 存储器

MAR位数反映存储单元的个数  ($2^{位数}$ 个地址)
MDR位数 = 存储字长 = 每个存储单元的大小

总容量(bit)= 存储单元个数 x 存储字长

n个二进制位 一共能表示出 $2^n$ 个状态

​	$2^{10}$ = 1024 = K
​	$2^{20}$ = M
​	$2^{30}$ = G
​	$2^{40}$ = T

#### CPU

1️⃣ **CPU主频** (单位: 赫兹, Hz)：CPU内数字脉冲信号振荡的频率

CPU时钟周期 (单位：微秒、纳秒) = 每个脉冲信号的间隔

 $CPU主频 (时钟频率) = \frac{1}{CPU时钟周期}$

**注**：描述频率Hz时：K=$10^3$, M=$10^6$, G=$10^9$, T=$10^{12}$, P=$10^{15}$, E=$10^{18}$, Z=$10^{21}$
	描述文件大小时：K=$2^{10}$, M=$2^{20}$, G=$2^{30}$, T=$2^{40}$

2️⃣ **CPI** (Clock cycle Per Instruction): 执行一条指令所需要的**时钟周期数**

**执行一条指令的耗时 = CPI x CPU时钟周期**

**\*CPU执行时间**(整个程序的耗时) = $\frac{CPU时钟周期数}{主频}$ = $\frac{(指令条数)*CPI}{主频}$

3️⃣ **IPS** (Instructions Per Second): 每秒执行多少条指令 = $\frac{主频}{平均CPI}$

4️⃣ FLOPS : 每秒执行多少次浮点运算

#### 系统整体

**数据通路带宽**：数据总线一次所能并行传送信息的位数

**吞吐量**：系统在单位时间内处理请求的数量

**响应时间**：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间

**基准程序**：测量计算机处理速度的程序 (跑分软件)



## 2 数据的表示和运算

### 2.1.1 进位计数制

**各种进制的常见书写方式** ⬇️

- 二进制 10100010B
- 八进制 1652 (默认)
- 十六进制 (hexadecimal) 1652H 或 0x1652
- 十进制 (decimals) 1652D

#### **考点1️⃣：任意进制 -> 十进制**

r进制的数值 = 各数码位与位权的乘积之和

#### **考点2️⃣：二进制 <-> 八进制 ; 二进制 <-> 十六进制**

**二进制 -> 八进制** 方法：3位一组，每组转换成对应的八进制符号
**二进制 -> 十六进制** 方法：4位一组，每组转换为对应的十六进制符号

#### **考点3️⃣：十进制 -> 任意进制**

**整数部分：除基取余法** (短除法) 先取的"余"是整数的低位
**小数部分：乘基取整法** (短乘法) 先取的"整"是小数的高位

快捷方式 **拼凑法**
	先罗列出简单的二进制横表 再拼凑，如果是转换成8或16进制，可以先转化为2进制再转化为8/16进制
	例：260.75D 转为二进制数，260=256+4=$2^8+2^2$ 即除了第8位和第2位是1 其他都是0 = 100000100B
		小数部分 0.75=0.5+0.25=$2^{-1}+2^{-2}$ = 11B

注：有的十进制小数无法用二进制精确表示

#### **考点4️⃣：真值和机器数**

真值：符合人类习惯的数字
机器数：数字实际存到机器里的形式，正负号需要呗"数字化"
	例： +15 -> 0 1111 (0表示正)                    -8 -> 1 1000 (1表示负)



### 2.1.2&2.1.3 定点数的编码表示

#### **无符号数**

整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值 (通常只有无符号整数)

n位的无符号数**表示范围**为：0 ~ $2^n-1$

#### **有符号数的定点表示**

定点整数：**符号位 数值部分** 小数点位置(隐含)
定点小数：**符号位** 小数点位置(隐含) **数值部分(也称为尾数)**

可用 **原码、反码、补码** 三种方式表示**整数和定点小数**；还可以用**移码**表示定点整数。

#### 原码

用尾数表示真值的绝对值，符号为"0/1", 对应"正/负"

**表示范围**：若机器字长n+1位
	**原码整数**的表示范围：$-{(2^n-1)}$ ≤ $2^{n}-1$
	**原码小数**的表示范围：$-(1-2^{-n})$ ≤ $x$ ≤ $1-2^{-n}$
真值0 有 +0和 -0两种形式

#### 反码

​	反码只是原码转变为补码的一个中间状态，实际中并无作用

**转变方式**：若符号位为0，则反码与原码相同；若符号位为1，则数值位全部取反

反码整数 和 反码小数 的表示范围 和原码的表示范围一致

#### 补码

正数的补码 = 原码
负数的补码 = 反码末位+1 (要考虑进位)

**补码的真值 0 只有一种表示形式**

定点整数补码$[x]_补$ = 1,000 0000 表示 x=$-2^7$；若机器字长n+1位，补码整数的表示范围：$-2^n$ ≤ $x$ ≤ $2^n-{1}$ (比原码多表示一个 $-2^n$)

定点小数补码$[x]_补$ = 1.000 0000表示 x=$-1$；若机器字长n+1位，补码小数的表示范围：$-1$ ≤ $x$ ≤ $1-2^{-n}$ (比原码多表示一个 $-1$)

**补码 -> 原码 方法：尾数(数值位)取反，末位+1**

#### 移码

**移码：补码的基础上将符号位取反。移码只能用于表示整数**

**移码的真值 0 只有一种表示形式**

移码的表示范围与补码一致

将移码整体看作无符号整数，就能很方便的对比数字的 大小

#### 小技巧

由$x$的补码 快速求$-x$的补码 方法：符号位、数值位全部取反，末位+1

![2.1.2&2.1.3总结](../assets/CO/2_1_2.jpeg)
