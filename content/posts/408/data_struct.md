---
title: 'DataStruct - 数据结构'
date: 2024-11-25T18:06:22+08:00
draft: false
tags: ['C','408']
---

# 数据结构

## 1 数据结构基本概念

数据：

- 数据对象 (具有**相同性质**的数据元素的集合)
  - 数据元素 
    - 数据项
- 数据结构 (相互之间存在一种或多种特定关系的**数据元素的集合**)
- 数据类型、抽象数据类型
  - 原子类型 - 其值不可再分
  - 结构类型 - 其值可以再分解成若干分量



### 1.1 数据结构三要素

1. 逻辑结构 **(*定义)**
   - 集合结构
   - 线性结构 - 一对一 。
     - 有开头，有结尾
   - 树形结构 - 一对多
   - (网)图状结构 - 多对多
2. 数据的运算
   - 增删改查
3. 物理结构(存储结构) **(*实现)**
   - **顺序存储**
   - 非顺序存储
     - **链式存储**
     - **索引存储** - 存储元素信息的同时，建立附加的索引表
     - **散列存储** - Hash存储

数据的存储结构会影响存储空间分配的方便程度，也会影响对数据运算的速度

![](../assets/data_struct/1.1_1.png)

### 1.2 算法 Algorithm

算法：对特定问题求解步骤的一种描述，它是指令的有限序列

​	程序 = 数据结构 + 算法

#### 1.2.1 算法的特性

- 有穷性 - 一个算法必须在执行有穷步后结束，且每一步都在有穷时间内完成
- 确定性 - 算法中每条指令必须有确切的含义，对于相同的输入必须得到相同的输出
- 可行性 - 算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
- 输入 - 一个算法有**零个或多个**输入
- 输出 - 一个算法有**一个或多个**输出

#### 1.2.2 好算法的特性

- 正确性 - 算法应能够正确的解决问题
- 可读性
- 健壮性
- 高效率与低存储量需求

#### *1.2.3 算法效率的度量

##### 时间复杂度

​	事先预估算法**时间开销T(n)**与**问题规模n**的关系

大O表示法

- T1(n) = O(n)
- T2(n) = O(n^2)
- T3(n) = O(n^3)

复杂度量级排序：**常对幂指阶** 

![image-20241125184429729](../assets/data_struct/1.2_1.png)

- 顺序执行的代码只会影响常数项，可以忽略
- 只需挑**循环中的一个基本操作**分析它的执行次数与n的关系即可
- 如果有多层嵌套循环，只需关注最深层循环 循环了几次

![image-20241125185824828](../assets/data_struct/1.2_2.png)

##### 空间复杂度

![image-20241126151214824](../assets/data_struct/1.2_3_2.png)

![image-20241126151841651](../assets/data_struct/1.2_3_3.png)



## 2 线性表

逻辑结构上 a1-a2-a3-a4-a5

物理结构上分为：

- 顺序存储
- 链式存储

### 2.1 定义和基本操作

线性表是具有**相同数据类型**的**n**(n>=0)个**数据元素**的**有限序列**。
L = (a1, a2, ... , ai, a(i+1), ... , an )

注意：数据元素的**位序从1开始**

### 2.2 顺序表

顺序表的特点：

- 随机访问，可以在O(1)时间内找到第i个元素 -> data[i-1]
- 存储密度高，每个节点只存储数据元素
- 要求大片连续空间，拓展容量不方便
- 插入、删除操作不方便，需要移动大量元素

代码实现：

​	**[List.cpp](https://github.com/foryyz/Programming-Basic-Projects/blob/main/Data_Struct_408/ListStruct/List.cpp)**

### 2.3 单链表

单链表的特点：

- 优点：不要求大片连续空间，改变容量方便
- 缺点：不可随机存取，要耗费一定空间存放指针

考点：

- **[头插法逆置单链表](https://github.com/foryyz/Programming-Basic-Projects/blob/main/Data_Struct_408/ListStruct/LinkList.cpp#L155)**

代码实现：

​	**[LinkList.cpp](https://github.com/foryyz/Programming-Basic-Projects/blob/main/Data_Struct_408/ListStruct/LinkList.cpp)**

### 2.4 双链表

解决了**单链表无法逆向检索**的缺点

代码实现：

​	**[DoubleLinkList.cpp](https://github.com/foryyz/Programming-Basic-Projects/blob/main/Data_Struct_408/ListStruct/DoubleLinkList.cpp)**

### 2.5 循环链表

#### 2.5.1 循环单链表

特点：从一个结点出发，可以到达任意一个结点。

拓：如果设定 链表L指向末尾结点，可以在循环单链表基础上更高效的提高对头尾操作的效率

代码实现：

​	**[CircularLinkList.cpp](https://github.com/foryyz/Programming-Basic-Projects/blob/main/Data_Struct_408/ListStruct/CircularLinkList.cpp)**

#### 2.5.2 循环双链表

![循环双链表结构图](../assets/data_struct/2.5.2_1.png)

代码实现：

​	**[CircularDoubleLinkList.cpp](https://github.com/foryyz/Programming-Basic-Projects/blob/main/Data_Struct_408/ListStruct/CircularDoubleLinkList.cpp)**

### 2.6 静态链表

(早期不支持指针的低级语言 使用这个数据结构 代替单链表)

单链表：各个结点在内存中星罗棋布
静态链表：分配一整片连续的内存空间，各个结点集中安置

特点：容量固定不变, 不可以拓展

- 优点：增、删 操作不需要大量移动元素
- 缺点：不能随机存取，只能从头结点开始依次往后查

定义：每**一个静态链表的结点** 包含**本身的数据** 和**下一个结点的数组索引**

代码实现：

​	[StaticLinkList.cpp](https://github.com/foryyz/Programming-Basic-Projects/blob/main/Data_Struct_408/ListStruct/StaticListList.cpp)

### 2.7 顺序表和链表的对比

#### 2.7.1 逻辑结构对比

​	都属于线性表，都是线性结构

#### 2.7.2 物理结构对比

- 顺序表：
  - 支持随机存取、存储密度高
  - 需要大片连续内存，改变容量不方便
- 链表：
  - 离散的小空间分配方便，改变容量方便
  - 不可随机存取、存储密度低

#### 2.7.3 基本操作对比

**创：**

- **创建顺序表**时，因为拓展容量不方便，**需要预分配大片连续空间**。若分配过大则会浪费内存资源。
- **创建链表**时，只需要声明一个头指针，并可以按需求选择是否分配头结点

**销：**

- 销毁顺序表
  - 静态分配内存时，只需要修改Lenght=0，生命周期结束后自动回收
  - 动态(malloc)分配内存时，需要手动free(L.data)
- 销毁链表，需要一次删除各个结点free()

**增删：**

- 顺序表
  - 插入/删除 元素 都要将所有元素 进行前移/后移
  - 时间复杂度O(n), 主要来自于移动元素
- 链表
  - 插入/删除 只需要修改对应指针即可
  - 时间复杂度O(n), 主要来自于找到目标元素，但**一般来说 增删元素 链表的效率要比顺序表高**

**查：**

- 顺序表 支持随机存取
  - 按位查找 O(1)
  - 按值查找 O(n) ，若表内元素有序，可在O(log2n)时间内找到
- 链表
  - 按位查找 和 按值查找 都是 O(n)

一般来说，**查找元素 顺序表的效率要比链表高**

#### 2.7.4 如何选择

|              | 顺序表 | 链表 |
| ------------ | ------ | ---- |
| 弹性(可扩容) | 😭      | 😄    |
| 增、删       | 😭      | 😄    |
| 查           | 😄      | 😭    |

表长难以估计、经常需要增/删元素  -> 链表
表长可预估、经常需要查询(搜索) -> 顺序表

## 3 栈

**栈：只允许在一端进行插入或删除操作的线性表**

特点：先进后出，后进先出 **Last In First Out (LIFO)**

重要术语：

- 栈顶：允许插入和删除的一端
- 栈底：不允许插入和删除的一端
- 空栈

### 3.1 顺序栈

使用静态数组实现，并需要记录栈顶指针

设计方式(需要理解不同设计方式 的 不同代码实现)：

- 初始化时 top=-1;
- 初始化时 top=0;

缺点：栈的大小不可变

代码实现：

​	**[SqStack.cpp]()**

### 3.2 共享栈

两个栈共享同一片内存空间

代码实现：

​	[ShStack.cpp](https://github.com/foryyz/Programming-Basic-Projects/blob/main/Data_Struct_408/Stack/ShStack.cpp)

### 3.3 链栈

**链栈**相当于是**只能对头结点进行**后插和后删操作的**单链表**
链头 = 栈顶

推荐在实现链栈时使用不带头结点的单链表

代码实现：

​	**[LinkStack.cpp](https://github.com/foryyz/Programming-Basic-Projects/blob/main/Data_Struct_408/Stack/LinkStack.cpp)**
